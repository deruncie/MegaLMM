% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MegaLMM_master.R
\name{MegaLMM_control}
\alias{MegaLMM_control}
\title{Set MegaLMM run parameters}
\usage{
MegaLMM_control(
  which_sampler = list(Y = 1, F = 1),
  run_sampler_times = 1,
  scale_Y = c(T, F),
  K = 20,
  h2_divisions = 100,
  h2_step_size = NULL,
  drop0_tol = 1e-14,
  K_eigen_tol = 1e-10,
  burn = 100,
  thin = 2,
  max_NA_groups = Inf,
  svd_K = TRUE,
  verbose = TRUE,
  save_current_state = TRUE,
  diagonalize_ZtZ_Kinv = TRUE,
  ...
)
}
\arguments{
\item{which_sampler}{List with two elements (Y and F) specifying which sampling function
to use for the observations (Y) and factors (F). Each is a number in 1-4. 1-3 are block updators. 4 is a single-site updater.
MegaLMM uses 1-3 depending on data dimensions.
MegaBayesC uses 4 which updates each coefficient individually.}

\item{run_sampler_times}{For \code{which_sampler==4}, we can repeat the single-site sampler multiple times to help take larger steps each iteration.}

\item{scale_Y}{Should the Y values be centered and scaled? Recommend, except for simulated data.}

\item{K}{number of factors}

\item{h2_divisions}{A scalar or vector of length equal to number of random effects. In MegaLMM, random
effects are parameterized as proportions of the total variance of all random effects plus residuals. 
The prior on the variance componets is discrete spanning the interval [0,1) over each varince component proportion
with \code{h2_divisions} equally spaced values is constructed. If
\code{h2_divisions} is a scalar, the prior for each variance component has this number of divisions. 
If a vector, the length should equal the number of variance components, in the order of the random effects specified in the model}

\item{h2_step_size}{Either NULL, or a scaler in the range (0,1].
If NULL, h2's will be sampled based on the marginal probability over all possible h2 vectors. 
If a scalar, a Metropolis-Hastings update step will be used for each h2 vector.
The trail value will be selected uniformly from all possible h2 vectors within this Euclidean distance from the current vector.}

\item{drop0_tol}{A scalar giving the a tolerance for the \code{drop0()} function that will be applied
to various symmetric (possibly) sparse matrices to try to fix numerical errors and increase sparsity.}

\item{K_eigen_tol}{A scalar giving the minimum eigenvalue of a K matrix allowed. During pre-processing,
eigenvalues of each K matrix will be calculated using \code{svd(K)}. Only eigenvectors of K with corresponding eigenvalues
greater than this value will be kept. If smaller eigenvalues exist, the model will be transformed
to reduce the rank of K, by multiplying Z by the remaining eigenvectors of K. This transformation
is undone before posterior samples are recorded, so posterior samples of \code{U_F} and \code{U_R} are
untransformed.}

\item{burn}{burnin length of the MCMC chain}

\item{thin}{thinning rate of the MCMC chain}

\item{max_NA_groups}{If 0, all NAs will be imputed during sampling. If Inf, all NAs will be marginalized over.
If in (0,Inf), up to this many groups of columns will be separately sampled.
The minimum number of NAs in each column not in one of these groups will be imputed.}

\item{svd_K}{If TRUE, the the diagonalization of ZKZt for the first random effect is accomplished using this algorithm:
https://math.stackexchange.com/questions/67231/singular-value-decomposition-of-product-of-matrices which doesn't require forming ZKTt.
If FALSE, the SVD of ZKZt for the first random effect is calculated directly. TRUE is generally faster if the same genomes are repeated several times.}

\item{verbose}{should progress during initiation and sampling be printed?}

\item{save_current_state}{should the current state of the sampler be saved every time the function \code{sample_MegaLMM} is called?}
}
\description{
Function to create run_parameters list for initializing MegaLMM model
}
\seealso{
\code{\link{MegaLMM_init}}, \code{\link{sample_MegaLMM}}, \code{\link{print.MegaLMM_state}}
}
